title: PyScript!
---
author: David Antonini
---
meta_description: PyScript: a plethora of possibilities
---
pub_date: 2022-06-20
---
subtitle: Oh the things PyScript can let us do
---
twitter_handle: toonarmycaptain
---
meta_keywords: 

python
pyscript
---
tags:

python
frontend
pyscript
webdev
---
_discoverable: yes
---
body:


##### This intro needs work

When working with the frontend, logic is written in Javascript. However, most kids, and a lot of backend engineers learn and use python as their primary language. This, coupled with machine learning and datascience being dominated by python, now we can bring a frontend logic alternative using PyScript. 

Fear js no more - PyScript is here. 


PyScript is a framework that allows python code to run in the browser with near-native speed.

This is accomplished with a toolchain of Pyodide-Emscripten-WASM. Pyodide takes CPython, adds an interface between python and Typescript/JavaScript, and using Emscripten compiles it down to WASM (WebAssembly). WASM binaries executes at near-native speed and is supported by all major browsers. 


With PyScript we can:
  - run python in the browser
  - import stdlib, PyPI, and user-authored dependencies. 
  - interact with JavaScript/DOM and browser APIs

To use PyScript you just add these lines to your HTML:
```html
<html>
    <head>
        <link rel="stylesheet" href="https://pyscript.net/alpha/pyscript.css" />
        <script defer src="https://pyscript.net/alpha/pyscript.js"></script>
    </head>
</html>
```


PyScript defines several custom HTML tags:

##&lt;py-script>

This is where you type your Python code!
# example graphic side by side with output (do we need the full <html><head> boilerplate? )
<div id="hello-world" style="float: right; width: 50%;">
    <img src="hello-world.png" alt="hello-world.png" alt="hello-world.png" style="float: left; "/>
</div>

```html
<py-script>
print('Hello from py-script!')
</py-script>
```

##&lt;py-env>

You can specify dependencies from PyPI or your own code:

```html
<py-env>
  - numpy
  - pandas
  - pytorch
  - plusminus
</py-env>
```

Yes, numpy, pandas, matplotlib are all pre-compiled for WASM(get details), so none of the portability issues often experienced with data libraries with a lot of C code exist: it compiles to WASM and runs at near-native speed. 
  
You can specify your own files too:
 
# graphic with a pretty plot below the matplotlib code:

```html
<py-env>
  - matplotlib
  - paths:
      - my_code.py
      - my_data.csv
      - plot_background.jpg
</py-env>
```

And then use them:

```html
<py-script>
import matplotlib.pyplot as plt
from my_code import my_algorithm

print('Here's the plot of my data:')

with open('my_data.csv') as f:
    data = f.readlines()

output = my_algorithm(data)

# code plotting with matplotlib with plot_background.jpg  
plt.plot(output, 'plot_background.jpg')
plt # Like print() this will display the plot.
</py-script>

```
<img src="https://i.stack.imgur.com/oyl6c.jpg" width=900px alt="placeholder image from https://stackoverflow.com/questions/13570287/image-overlay-in-3d-plot-using-python"/>

Yep, you can pull your own code along for the ride and import it inside your `<py-script>` tags. You can actually bundle files of any type and use them in your code.
We can also see here how you can display output from code to the browser.  
 
##&lt;py-repl>

Pyscript also comes with a built-in repl tag:

```html
<py-repl std-out="pyrepl-std-out" std-err="pyrepl-std-err">
</py-repl>

<div id=repl-output>
    <b>std-out</b>
    <div id="pyrepl-std-out"></div>
    <b>std-err</b>
    <div id="pyrepl-std-err"></div>
</div>
```

<div id="pyrepl">
# uncommenting this stylesheet breaks the lektor css, and when uncommented makes the std-err out weird colours compared to when rendered by itself.

<!-- (  <link rel="stylesheet" href="https://pyscript.net/alpha/pyscript.css" /> -->
  <script defer src="https://pyscript.net/alpha/pyscript.js"></script>
  
  <py-repl std-out="pyrepl-std-out" std-err="pyrepl-std-err"></py-repl>
 
  <div id=repl-output>
    <b>std-out</b>
    <div id="pyrepl-std-out"></div>
    <b>std-err</b>
    <div id="pyrepl-std-err"></div>
  </div>
</div>

# Why are these closing div tags rendering, and why is there a py-repl closing tag in my repl input box? NB it breaks if I omit the closing tag
# also I don't know how to make the repl wider and to style/format the output divs
<br>If you type python code in the repl above, and then hit `Shift+enter` or click the red arrow to run it, you can see output under either the `std-out` or `std-err` headings. 


There are also the `<py-button>` and `<py-inputbox>` widgets that allow you to call python code from click and keypress events respectively, and PyBox, a container object that can define how it's elements are arranged and displayed Ã  la CSS Flexbox. 


What does this mean, aside from being able to write Python instead of JavaScript on the frontend?


Despite [warnings](https://pyscript.net/) that PyScript is "very alpha" and changes should be expected, the possibilities it enables have the potential for it to prove one of the most pivotal developments of the decade in frontend development, and web development generally.

Python has always had portability and GUI challenges. PyScript offers both a GUI for Python that is both portable wherever there is a web browser and leverages existing frontend technologies with the extensibility of Python's power as a glue between tools. 
In addition to GUI, PyScript in the browser is a single target platform for Python developers to deliver native cross-platform applications, even offering the prospect of relatively trivial mobile development, by wrapping PyScript based web applications with mobile-native languages, (similar to what Electron has done for JavaScript?). 

This ability to offer native cross-platform experiences with Python frees ML and Datascience developers to ship their computation-heavy applications off servers and in to client devices. Got an application that runs on sensitive data that clients would rather keep on their machines? Ship the application with PyScript, and clients can leverage your application without their data ever leaving their machine. 
Any code that can run on a client, but generally doesn't because of installation/dependency issues, can be clientside with PyScript. Numpy is infamous for being difficult to install, but it's already compiled for WASM everywhere. Any tools or code that can be compiled to WASM that Python can hook into can be leveraged together, client-side. As (link) Peter Wang demonstrated at PyCon, motion-control married to software emulation married to GUI can be delivered in-browser.
Even with large packages, browser-nativity shines, as caching can preserve these resources in the client, handily also enabling offline utility. 


Terminal Labs has been enthralled to be a part of bringing PyScript to a browser near you, please reach out to us; we can help you bring your special sauce to the plate of your clients' browsers.
